package setup

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"agents-admin/internal/nodemanager"
)

func TestGenerateToken(t *testing.T) {
	token := generateToken()
	if len(token) != 64 {
		t.Errorf("expected token length 64, got %d", len(token))
	}
	// 确保每次生成不同的 token
	token2 := generateToken()
	if token == token2 {
		t.Error("expected different tokens on each call")
	}
}

func TestGenerateNodeID(t *testing.T) {
	id := nodemanager.GenerateNodeID()
	// UUID 风格格式: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
	if len(id) < 32 {
		t.Errorf("expected ID length >= 32, got %d: %s", len(id), id)
	}
	if !strings.Contains(id, "-") {
		t.Errorf("ID should contain dashes: %s", id)
	}
	// 确定性：同一台机器每次调用结果相同
	id2 := nodemanager.GenerateNodeID()
	if id != id2 {
		t.Errorf("deterministic ID should be consistent: %s != %s", id, id2)
	}
	t.Logf("Deterministic Node ID: %s", id)
}

func TestGetDefaultWorkspaceDir(t *testing.T) {
	dir := getDefaultWorkspaceDir()
	if dir == "" {
		t.Error("default workspace dir should not be empty")
	}
	t.Logf("Default workspace dir: %s", dir)
}

func TestTestWorkspaceDir(t *testing.T) {
	// 测试有效目录
	tmpDir := t.TempDir()
	result := testWorkspaceDir(tmpDir)
	if !result.OK {
		t.Errorf("expected OK for temp dir, got: %s", result.Message)
	}

	// 测试空路径
	result = testWorkspaceDir("")
	if result.OK {
		t.Error("expected failure for empty dir")
	}
}

func TestWriteConfig(t *testing.T) {
	tmpDir := t.TempDir()
	configPath := filepath.Join(tmpDir, "test", "dev.yaml")

	cfg := &SetupConfig{}
	cfg.Node.ID = "test-node-01"
	cfg.APIServer.URL = "https://192.168.1.100:8080"
	cfg.Node.WorkspaceDir = "/tmp/test-ws"
	cfg.TLS.Enabled = true
	cfg.TLS.CAFile = "/etc/certs/ca.pem"

	err := writeConfig(configPath, cfg)
	if err != nil {
		t.Fatalf("writeConfig failed: %v", err)
	}

	// 验证文件存在
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		t.Fatal("config file not created")
	}

	// 验证文件内容
	data, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatalf("failed to read config: %v", err)
	}

	content := string(data)
	if !strings.Contains(content, "test-node-01") {
		t.Error("config should contain node ID")
	}
	if !strings.Contains(content, "https://192.168.1.100:8080") {
		t.Error("config should contain API server URL")
	}
	if !strings.Contains(content, "Generated by Setup Wizard") {
		t.Error("config should contain header comment")
	}

	// 验证文件权限
	info, _ := os.Stat(configPath)
	perm := info.Mode().Perm()
	if perm != 0640 {
		t.Errorf("expected permission 0640, got %o", perm)
	}
}

func TestHandleInfo(t *testing.T) {
	srv := &Server{
		configPath: "/tmp/test/dev.yaml",
		token:      "test-token",
	}

	req := httptest.NewRequest(http.MethodGet, "/setup/api/info", nil)
	w := httptest.NewRecorder()

	srv.handleInfo(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("expected 200, got %d", w.Code)
	}

	var resp InfoResponse
	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
		t.Fatalf("failed to decode response: %v", err)
	}

	if resp.Hostname == "" {
		t.Error("hostname should not be empty")
	}
	if resp.GeneratedNodeID == "" {
		t.Error("generated_node_id should not be empty")
	}
	if resp.DefaultWorkspaceDir == "" {
		t.Error("default_workspace_dir should not be empty")
	}
}

func TestHandleInfoMethodNotAllowed(t *testing.T) {
	srv := &Server{token: "test-token"}

	req := httptest.NewRequest(http.MethodPost, "/setup/api/info", nil)
	w := httptest.NewRecorder()

	srv.handleInfo(w, req)

	if w.Code != http.StatusMethodNotAllowed {
		t.Fatalf("expected 405, got %d", w.Code)
	}
}

func TestHandleValidate(t *testing.T) {
	srv := &Server{token: "test-token"}

	body := `{
		"node": {"id": "test", "api_server_url": "http://127.0.0.1:99999"},
		"tls": {"enabled": false, "ca_source": "skip"}
	}`

	req := httptest.NewRequest(http.MethodPost, "/setup/api/validate", strings.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	srv.handleValidate(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("expected 200, got %d", w.Code)
	}

	var resp ValidateResponse
	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
		t.Fatalf("failed to decode response: %v", err)
	}

	// API Server 应该连接失败（无效端口）
	if resp.Checks["api_server"].OK {
		t.Error("api_server should fail on invalid port")
	}

	// Workspace 应该成功
	if !resp.Checks["workspace"].OK {
		t.Errorf("workspace should succeed, got: %s", resp.Checks["workspace"].Message)
	}
}

func TestHandleValidateBadJSON(t *testing.T) {
	srv := &Server{token: "test-token"}

	req := httptest.NewRequest(http.MethodPost, "/setup/api/validate", strings.NewReader("invalid"))
	w := httptest.NewRecorder()

	srv.handleValidate(w, req)

	if w.Code != http.StatusBadRequest {
		t.Fatalf("expected 400, got %d", w.Code)
	}
}

func TestTokenAuthMiddleware(t *testing.T) {
	srv := &Server{token: "secret-token-123"}

	handler := srv.tokenAuthMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("OK"))
	}))

	// 无 Token: 403
	req := httptest.NewRequest(http.MethodGet, "/test", nil)
	w := httptest.NewRecorder()
	handler.ServeHTTP(w, req)
	if w.Code != http.StatusForbidden {
		t.Fatalf("expected 403 without token, got %d", w.Code)
	}

	// URL Query Token: 200
	req = httptest.NewRequest(http.MethodGet, "/test?token=secret-token-123", nil)
	w = httptest.NewRecorder()
	handler.ServeHTTP(w, req)
	if w.Code != http.StatusOK {
		t.Fatalf("expected 200 with URL token, got %d", w.Code)
	}

	// Cookie Token: 200
	req = httptest.NewRequest(http.MethodGet, "/test", nil)
	req.AddCookie(&http.Cookie{Name: "setup_token", Value: "secret-token-123"})
	w = httptest.NewRecorder()
	handler.ServeHTTP(w, req)
	if w.Code != http.StatusOK {
		t.Fatalf("expected 200 with cookie token, got %d", w.Code)
	}

	// Authorization Header Token: 200
	req = httptest.NewRequest(http.MethodGet, "/test", nil)
	req.Header.Set("Authorization", "token secret-token-123")
	w = httptest.NewRecorder()
	handler.ServeHTTP(w, req)
	if w.Code != http.StatusOK {
		t.Fatalf("expected 200 with auth header token, got %d", w.Code)
	}

	// Wrong Token: 403
	req = httptest.NewRequest(http.MethodGet, "/test?token=wrong", nil)
	w = httptest.NewRecorder()
	handler.ServeHTTP(w, req)
	if w.Code != http.StatusForbidden {
		t.Fatalf("expected 403 with wrong token, got %d", w.Code)
	}
}

func TestHandleBootstrapMethodNotAllowed(t *testing.T) {
	srv := &Server{token: "test-token", configPath: "/tmp/test.yaml"}

	req := httptest.NewRequest(http.MethodGet, "/setup/api/bootstrap", nil)
	w := httptest.NewRecorder()
	srv.handleBootstrap(w, req)

	if w.Code != http.StatusMethodNotAllowed {
		t.Fatalf("expected 405, got %d", w.Code)
	}
}

func TestHandleBootstrapEmptyURL(t *testing.T) {
	srv := &Server{token: "test-token", configPath: "/tmp/test.yaml"}

	body := `{"api_server_url": ""}`
	req := httptest.NewRequest(http.MethodPost, "/setup/api/bootstrap", strings.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	srv.handleBootstrap(w, req)

	if w.Code != http.StatusBadRequest {
		t.Fatalf("expected 400, got %d", w.Code)
	}
}

func TestHandleBootstrapUnreachable(t *testing.T) {
	srv := &Server{token: "test-token", configPath: filepath.Join(t.TempDir(), "dev.yaml")}

	body := `{"api_server_url": "http://127.0.0.1:1"}`
	req := httptest.NewRequest(http.MethodPost, "/setup/api/bootstrap", strings.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	srv.handleBootstrap(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("expected 200, got %d", w.Code)
	}

	var resp BootstrapResponse
	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
		t.Fatalf("failed to decode: %v", err)
	}
	if resp.OK {
		t.Error("should not be OK for unreachable server")
	}
	if !strings.Contains(resp.Message, "Cannot connect") {
		t.Errorf("expected 'Cannot connect' message, got: %s", resp.Message)
	}
}

func TestGetLocalIPs(t *testing.T) {
	ips := getLocalIPs()
	// 至少应该有一个非回环 IP（在大多数环境中）
	// 但在某些 CI 环境可能没有，所以只验证不 panic
	t.Logf("Local IPs: %v", ips)
}

func TestIsUnderSystemd(t *testing.T) {
	// 在测试环境中不应该在 systemd 下
	// 除非设置了 INVOCATION_ID
	original := os.Getenv("INVOCATION_ID")
	defer os.Setenv("INVOCATION_ID", original)

	os.Unsetenv("INVOCATION_ID")
	// ppid 不太可能是 1 在测试中
	if os.Getppid() != 1 {
		if isUnderSystemd() {
			t.Error("should not detect systemd in test environment")
		}
	}

	os.Setenv("INVOCATION_ID", "test-invocation")
	if !isUnderSystemd() {
		t.Error("should detect systemd when INVOCATION_ID is set")
	}
}
