package setup

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"agents-admin/internal/config"
	"agents-admin/internal/shared/sysinstall"

	"github.com/oasdiff/yaml"
)

// ========== Config File Writers ==========

func writeYAMLConfig(dir string, cfg ValidateRequest) error {
	path := filepath.Join(dir, config.ConfigFileName())

	// 读取已有配置（如 Node Manager 先安装）
	existing := make(map[string]interface{})
	if data, err := os.ReadFile(path); err == nil {
		yaml.Unmarshal(data, &existing)
	}

	// 构建 API Server 章节
	newSections := map[string]interface{}{
		"api_server": map[string]interface{}{
			"port": cfg.Server.Port,
		},
		"redis": map[string]interface{}{
			"host": cfg.Redis.Host,
			"port": cfg.Redis.Port,
			"db":   0,
		},
		"scheduler": map[string]interface{}{
			"node_id": "api-server",
		},
		"auth": map[string]interface{}{
			"access_token_ttl":  "15m",
			"refresh_token_ttl": "168h",
		},
	}

	// Database section
	switch cfg.Database.Type {
	case "sqlite":
		dbPath := cfg.Database.Path
		if dbPath == "" {
			dbPath = filepath.Join(sysinstall.DataDir, "agents-admin.db")
		}
		newSections["database"] = map[string]interface{}{
			"driver": "sqlite",
			"path":   dbPath,
		}
	case "mongodb":
		newSections["database"] = map[string]interface{}{
			"driver": "mongodb",
			"host":   cfg.Database.Host,
			"port":   cfg.Database.Port,
			"name":   cfg.Database.DBName,
		}
	default: // postgres
		newSections["database"] = map[string]interface{}{
			"driver":  "postgres",
			"host":    cfg.Database.Host,
			"port":    cfg.Database.Port,
			"user":    cfg.Database.User,
			"name":    cfg.Database.DBName,
			"sslmode": cfg.Database.SSLMode,
		}
	}

	// TLS section
	if cfg.TLS.Enabled {
		tlsMap := map[string]interface{}{"enabled": true}
		switch cfg.TLS.Mode {
		case "acme":
			acmeMap := map[string]interface{}{"enabled": true, "cache_dir": dir + "/certs/acme"}
			if cfg.TLS.AcmeDomains != "" {
				domains := strings.Split(cfg.TLS.AcmeDomains, ",")
				trimmed := make([]string, len(domains))
				for i, d := range domains {
					trimmed[i] = strings.TrimSpace(d)
				}
				acmeMap["domains"] = trimmed
			}
			if cfg.TLS.AcmeEmail != "" {
				acmeMap["email"] = cfg.TLS.AcmeEmail
			}
			tlsMap["acme"] = acmeMap
		case "manual":
			tlsMap["cert_file"] = dir + "/certs/server.pem"
			tlsMap["key_file"] = dir + "/certs/server-key.pem"
		default: // auto_generate
			tlsMap["auto_generate"] = true
			tlsMap["cert_dir"] = dir + "/certs"
			if cfg.TLS.Hosts != "" {
				tlsMap["hosts"] = cfg.TLS.Hosts
			}
		}
		newSections["tls"] = tlsMap
	}

	// 一级深度合并：保留已有章节（如 node），合并子字段
	mergeYAMLSections(existing, newSections)

	header := "# Agents Admin Configuration\n# Generated by Setup Wizard\n# " + time.Now().Format(time.RFC3339) + "\n\n"
	data, err := yaml.Marshal(existing)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}
	return os.WriteFile(path, []byte(header+string(data)), 0640)
}

// mergeYAMLSections 一级深度合并：如果新旧值都是 map，合并子字段；否则新值覆盖旧值
func mergeYAMLSections(existing, newSections map[string]interface{}) {
	for key, newVal := range newSections {
		if existingVal, ok := existing[key]; ok {
			if existingMap, ok := existingVal.(map[string]interface{}); ok {
				if newMap, ok := newVal.(map[string]interface{}); ok {
					for k, v := range newMap {
						existingMap[k] = v
					}
					continue
				}
			}
		}
		existing[key] = newVal
	}
}

func writeEnvConfig(dir string, cfg ValidateRequest, jwtSecret string) error {
	var b strings.Builder
	b.WriteString("# Agents Admin Sensitive Environment Variables\n")
	b.WriteString("# Generated by Setup Wizard\n")
	b.WriteString("# " + time.Now().Format(time.RFC3339) + "\n")
	b.WriteString("# WARNING: This file contains secrets. Keep permissions 0600.\n\n")

	b.WriteString("APP_ENV=prod\n\n")

	// Database credentials
	switch cfg.Database.Type {
	case "mongodb":
		if cfg.Database.User != "" {
			b.WriteString(fmt.Sprintf("MONGO_ROOT_USERNAME=%s\n", cfg.Database.User))
		}
		if cfg.Database.Password != "" {
			b.WriteString(fmt.Sprintf("MONGO_ROOT_PASSWORD=%s\n", cfg.Database.Password))
		}
	case "postgres":
		if cfg.Database.Password != "" {
			b.WriteString(fmt.Sprintf("DB_PASSWORD=%s\n", cfg.Database.Password))
		}
	}

	// Redis password
	if cfg.Redis.Password != "" {
		b.WriteString(fmt.Sprintf("REDIS_PASSWORD=%s\n", cfg.Redis.Password))
	}

	// MinIO credentials (from infra config, stored in Server struct)
	b.WriteString("\n")

	// Auth secrets
	b.WriteString(fmt.Sprintf("JWT_SECRET=%s\n", jwtSecret))
	b.WriteString(fmt.Sprintf("ADMIN_EMAIL=%s\n", cfg.Auth.AdminEmail))
	b.WriteString(fmt.Sprintf("ADMIN_PASSWORD=%s\n", cfg.Auth.AdminPassword))

	path := filepath.Join(dir, config.EnvFileName())
	return os.WriteFile(path, []byte(b.String()), 0600)
}
