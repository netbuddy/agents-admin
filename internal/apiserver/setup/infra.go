package setup

import (
	"bufio"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"agents-admin/deployments"
)

// ========== Infrastructure Deployment ==========

// handleGenerateInfra POST /setup/api/generate-infra
// 生成 docker-compose.yml + .env 文件（带随机密码）
func (s *Server) handleGenerateInfra(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req InfraGenerateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		// 允许空请求体，使用默认值
		req = InfraGenerateRequest{}
	}

	// 默认端口
	if req.MongoPort == 0 {
		req.MongoPort = 27017
	}
	if req.RedisPort == 0 {
		req.RedisPort = 6379
	}
	if req.MinIOAPIPort == 0 {
		req.MinIOAPIPort = 9000
	}
	if req.MinIOConsolePort == 0 {
		req.MinIOConsolePort = 9001
	}

	// 确保 infra 目录存在
	infraDir := filepath.Join(s.configDir, "infra")
	if err := os.MkdirAll(infraDir, 0755); err != nil {
		jsonResp(w, http.StatusInternalServerError, InfraGenerateResponse{
			Message: "Cannot create infra dir: " + err.Error(),
		})
		return
	}

	// 凭据：优先复用已有 .env（避免重复部署时密码不匹配）
	envFile := filepath.Join(infraDir, ".env")
	mongoUser := "agents_admin"
	mongoPassword := ""
	redisPassword := ""
	minioUser := "agents_minio_admin"
	minioPassword := ""

	if existingEnv, err := os.ReadFile(envFile); err == nil {
		// .env 已存在，解析已有凭据
		for _, line := range strings.Split(string(existingEnv), "\n") {
			line = strings.TrimSpace(line)
			if line == "" || strings.HasPrefix(line, "#") {
				continue
			}
			parts := strings.SplitN(line, "=", 2)
			if len(parts) != 2 {
				continue
			}
			switch parts[0] {
			case "MONGO_ROOT_USERNAME":
				mongoUser = parts[1]
			case "MONGO_ROOT_PASSWORD":
				mongoPassword = parts[1]
			case "REDIS_PASSWORD":
				redisPassword = parts[1]
			case "MINIO_ROOT_USER":
				minioUser = parts[1]
			case "MINIO_ROOT_PASSWORD":
				minioPassword = parts[1]
			}
		}
		log.Printf("Reusing existing infrastructure credentials from %s", envFile)
	}

	// 仅在没有已有凭据时生成新密码
	if mongoPassword == "" {
		mongoPassword = generateRandomString(24)
	}
	if redisPassword == "" {
		redisPassword = generateRandomString(24)
	}
	if minioPassword == "" {
		minioPassword = generateRandomString(24)
	}

	// 写 docker-compose.yml（嵌入的模板，总是覆盖以确保最新版本）
	composeFile := filepath.Join(infraDir, "docker-compose.yml")
	if err := os.WriteFile(composeFile, []byte(deployments.DockerComposeInfra), 0644); err != nil {
		jsonResp(w, http.StatusInternalServerError, InfraGenerateResponse{
			Message: "Cannot write docker-compose.yml: " + err.Error(),
		})
		return
	}

	// 写 .env 文件（总是覆盖以确保端口等配置是最新的）
	var envContent strings.Builder
	envContent.WriteString("# Agents Admin Infrastructure Credentials\n")
	envContent.WriteString("# Generated by Setup Wizard at " + time.Now().Format(time.RFC3339) + "\n")
	envContent.WriteString("# WARNING: Keep this file secure.\n\n")
	envContent.WriteString(fmt.Sprintf("MONGO_ROOT_USERNAME=%s\n", mongoUser))
	envContent.WriteString(fmt.Sprintf("MONGO_ROOT_PASSWORD=%s\n", mongoPassword))
	envContent.WriteString(fmt.Sprintf("MONGO_PORT=%d\n", req.MongoPort))
	envContent.WriteString(fmt.Sprintf("REDIS_PASSWORD=%s\n", redisPassword))
	envContent.WriteString(fmt.Sprintf("REDIS_PORT=%d\n", req.RedisPort))
	envContent.WriteString(fmt.Sprintf("MINIO_ROOT_USER=%s\n", minioUser))
	envContent.WriteString(fmt.Sprintf("MINIO_ROOT_PASSWORD=%s\n", minioPassword))
	envContent.WriteString(fmt.Sprintf("MINIO_API_PORT=%d\n", req.MinIOAPIPort))
	envContent.WriteString(fmt.Sprintf("MINIO_CONSOLE_PORT=%d\n", req.MinIOConsolePort))

	if err := os.WriteFile(envFile, []byte(envContent.String()), 0600); err != nil {
		jsonResp(w, http.StatusInternalServerError, InfraGenerateResponse{
			Message: "Cannot write .env: " + err.Error(),
		})
		return
	}

	// 保存状态
	s.infra.mu.Lock()
	s.infra.generated = true
	s.infra.composeFile = composeFile
	s.infra.envFile = envFile
	s.infra.mu.Unlock()

	log.Printf("Infrastructure files generated in %s", infraDir)

	jsonResp(w, http.StatusOK, InfraGenerateResponse{
		Success:          true,
		Message:          fmt.Sprintf("Files generated in %s", infraDir),
		MongoUser:        mongoUser,
		MongoPassword:    mongoPassword,
		MongoPort:        req.MongoPort,
		RedisPassword:    redisPassword,
		RedisPort:        req.RedisPort,
		MinIOUser:        minioUser,
		MinIOPassword:    minioPassword,
		MinIOAPIPort:     req.MinIOAPIPort,
		MinIOConsolePort: req.MinIOConsolePort,
		ComposeFile:      composeFile,
		EnvFile:          envFile,
	})
}

// handleDeployInfra POST /setup/api/deploy-infra
// 执行 docker compose up -d
func (s *Server) handleDeployInfra(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	s.infra.mu.Lock()
	if !s.infra.generated {
		s.infra.mu.Unlock()
		jsonResp(w, http.StatusBadRequest, InfraDeployResponse{
			Message: "Infrastructure files not generated yet. Call generate-infra first.",
		})
		return
	}
	if s.infra.deploying {
		s.infra.mu.Unlock()
		jsonResp(w, http.StatusConflict, InfraDeployResponse{
			Message: "Deployment already in progress.",
		})
		return
	}
	s.infra.deploying = true
	composeFile := s.infra.composeFile
	envFile := s.infra.envFile
	s.infra.mu.Unlock()

	// 检查 docker compose 是否可用
	dockerCompose := findDockerCompose()
	if dockerCompose == "" {
		s.infra.mu.Lock()
		s.infra.deploying = false
		s.infra.mu.Unlock()
		jsonResp(w, http.StatusInternalServerError, InfraDeployResponse{
			Message: "Docker Compose not found. Please install Docker and Docker Compose first.",
		})
		return
	}

	// 异步执行 docker compose up -d
	go func() {
		args := []string{}
		if filepath.Base(dockerCompose) == "docker" {
			args = append(args, "compose")
		}
		args = append(args, "-f", composeFile, "--env-file", envFile, "up", "-d")

		log.Printf("Running: %s %s", dockerCompose, strings.Join(args, " "))
		cmd := exec.Command(dockerCompose, args...)
		cmd.Dir = filepath.Dir(composeFile)

		var output strings.Builder
		cmd.Stdout = &output
		cmd.Stderr = &output

		err := cmd.Run()

		s.infra.mu.Lock()
		s.infra.deploying = false
		s.infra.deployOutput = output.String()
		if err != nil {
			s.infra.deployErr = err.Error()
			log.Printf("Deploy failed: %v\n%s", err, output.String())
		} else {
			s.infra.deployErr = ""
			log.Printf("Deploy succeeded:\n%s", output.String())
		}
		s.infra.mu.Unlock()
	}()

	jsonResp(w, http.StatusOK, InfraDeployResponse{
		Success: true,
		Message: "Deployment started. Check status with /setup/api/infra-status.",
	})
}

// handleInfraStatus GET /setup/api/infra-status
// 检查基础设施容器健康状态
func (s *Server) handleInfraStatus(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	s.infra.mu.Lock()
	generated := s.infra.generated
	deploying := s.infra.deploying
	composeFile := s.infra.composeFile
	envFile := s.infra.envFile
	deployErr := s.infra.deployErr
	s.infra.mu.Unlock()

	if !generated {
		jsonResp(w, http.StatusOK, InfraStatusResponse{Status: "not_deployed"})
		return
	}

	if deploying {
		jsonResp(w, http.StatusOK, InfraStatusResponse{Status: "starting", Message: "Docker Compose is starting services..."})
		return
	}

	if deployErr != "" {
		jsonResp(w, http.StatusOK, InfraStatusResponse{
			Status:  "error",
			Message: deployErr,
		})
		return
	}

	// 用 docker compose ps 查询状态
	dockerCompose := findDockerCompose()
	if dockerCompose == "" {
		jsonResp(w, http.StatusOK, InfraStatusResponse{Status: "error", Message: "Docker Compose not found"})
		return
	}

	args := []string{}
	if filepath.Base(dockerCompose) == "docker" {
		args = append(args, "compose")
	}
	args = append(args, "-f", composeFile, "--env-file", envFile, "ps", "--format", "json")

	cmd := exec.Command(dockerCompose, args...)
	cmd.Dir = filepath.Dir(composeFile)
	output, err := cmd.Output()
	if err != nil {
		jsonResp(w, http.StatusOK, InfraStatusResponse{
			Status:  "error",
			Message: fmt.Sprintf("Cannot check status: %v", err),
		})
		return
	}

	// 解析 docker compose ps --format json 输出
	services := make(map[string]ServiceStatus)
	allHealthy := true

	// docker compose ps --format json 输出每行一个 JSON 对象
	scanner := bufio.NewScanner(strings.NewReader(string(output)))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}
		var container struct {
			Name    string `json:"Name"`
			Service string `json:"Service"`
			State   string `json:"State"`
			Health  string `json:"Health"`
			Status  string `json:"Status"`
		}
		if err := json.Unmarshal([]byte(line), &container); err != nil {
			continue
		}
		svcName := container.Service
		if svcName == "" {
			svcName = container.Name
		}
		health := container.Health
		if health == "" {
			health = "none"
		}
		running := container.State == "running"
		services[svcName] = ServiceStatus{
			Running: running,
			Health:  health,
		}
		if !running || (health != "healthy" && health != "none") {
			allHealthy = false
		}
	}

	status := "unhealthy"
	if len(services) == 0 {
		status = "not_deployed"
	} else if allHealthy {
		status = "healthy"
	}

	jsonResp(w, http.StatusOK, InfraStatusResponse{
		Status:   status,
		Services: services,
	})
}

// findDockerCompose 查找 docker compose 命令
func findDockerCompose() string {
	// 优先 docker compose（V2 插件）
	if path, err := exec.LookPath("docker"); err == nil {
		cmd := exec.Command(path, "compose", "version")
		if cmd.Run() == nil {
			return path
		}
	}
	// 回退 docker-compose（V1 独立二进制）
	if path, err := exec.LookPath("docker-compose"); err == nil {
		return path
	}
	return ""
}
